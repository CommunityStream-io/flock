# WebdriverIO Best Practices

## Core Philosophy
**Leverage WebdriverIO's built-in auto-wait capabilities instead of manual waits.** WebdriverIO automatically waits for elements to be visible, enabled, and clickable when using interaction commands.

## Auto-Wait Principles

### ✅ What WebdriverIO Handles Automatically
- **Element Visibility**: `click()`, `setValue()`, `getText()` automatically wait for visibility
- **Element Interactability**: Commands wait for `isClickable()` conditions to be met
- **Element Enabled State**: Form interactions wait for enabled state
- **Element Stability**: Commands wait for element to be stable before interaction

### 🎯 When to Use Explicit Waits
Only use explicit waits for **visibility checks without interaction**:
```typescript
// ✅ Good: Wait for element to be visible without clicking
await element.waitForDisplayed({ timeout: 5000 });

// ✅ Good: Wait for element to disappear
await element.waitForDisplayed({ reverse: true, timeout: 5000 });

// ❌ Bad: Unnecessary wait before clicking
await element.waitForDisplayed();
await element.click(); // WebdriverIO already waits for visibility
```

## Element Interaction Patterns

### ✅ Preferred Patterns
```typescript
// Direct interaction - WebdriverIO auto-waits
await pages.auth.usernameField.setValue('test@example.com');
await pages.auth.passwordField.setValue('password123');
await pages.auth.submitButton.click();

// Visibility check without interaction
await pages.auth.successMessage.waitForDisplayed({ timeout: 5000 });

// Wait for element to disappear
await pages.auth.loadingSpinner.waitForDisplayed({ 
    reverse: true, 
    timeout: 10000 
});
```

### ❌ Anti-Patterns
```typescript
// ❌ Unnecessary explicit waits
await browser.waitUntil(async () => {
    const isVisible = await element.isDisplayed();
    const isEnabled = await element.isEnabled();
    return isVisible && isEnabled;
}, { timeout: 5000 });
await element.click(); // WebdriverIO already handles this

// ❌ Complex waitUntil for simple visibility
await browser.waitUntil(
    async () => await element.isDisplayed(),
    { timeout: 5000 }
);
// Better: await element.waitForDisplayed({ timeout: 5000 });
```

## Navigation and Page Load Patterns

### ✅ Simple Navigation Waits
```typescript
// Wait for specific element that indicates page is ready
await pages.auth.authForm.waitForDisplayed({ timeout: timeouts.navigation });

// Wait for navigation to complete by checking URL
await browser.waitUntil(
    async () => (await browser.getUrl()).includes('/auth'),
    { timeout: timeouts.navigation }
);
```

### ❌ Complex Navigation Waits
```typescript
// ❌ Overly complex navigation wait
await browser.waitUntil(
    async () => {
        const isOnStep = await pages.stepLayout.isOnStep('auth');
        const isFormVisible = await pages.auth.authForm.isDisplayed();
        const isFormEnabled = await pages.auth.authForm.isEnabled();
        return isOnStep && isFormVisible && isFormEnabled;
    },
    { timeout: timeouts.navigation }
);
```

## Form Validation Patterns

### ✅ Let WebdriverIO Handle Form Interactions
```typescript
// WebdriverIO auto-waits for form elements to be ready
await pages.auth.usernameField.setValue('test@example.com');
await pages.auth.passwordField.setValue('password123');
// No explicit wait needed - WebdriverIO handles form state
```

### ❌ Unnecessary Form Validation Waits
```typescript
// ❌ Don't wait for form validation unless checking specific state
await browser.waitUntil(
    async () => await pages.auth.isFormValid(),
    { timeout: 5000 }
);
// Only use this if you need to verify validation completed
```

## Dialog and Modal Patterns

### ✅ Simple Dialog Handling
```typescript
// Wait for dialog to appear
await pages.auth.helpDialog.waitForDisplayed({ timeout: 5000 });

// Wait for dialog to disappear
await pages.auth.helpDialog.waitForDisplayed({ 
    reverse: true, 
    timeout: 5000 
});

// Close dialog and wait for it to disappear
await pages.auth.closeHelpDialog();
await pages.auth.helpDialog.waitForDisplayed({ 
    reverse: true, 
    timeout: 5000 
});
```

## Timeout Configuration

### ✅ Use Centralized Timeout Config
```typescript
import { timeouts, timeoutMessages } from '../support/timeout-config';

// Use appropriate timeout for the operation
await element.waitForDisplayed({ timeout: timeouts.navigation });
await element.waitForDisplayed({ timeout: timeouts.fileProcessing });
await element.waitForDisplayed({ timeout: timeouts.dialogClose });
```

### ✅ Environment-Aware Timeouts
```typescript
// Use timeout messages that adapt to CI vs local
await browser.waitUntil(
    async () => condition,
    { 
        timeout: timeouts.navigation,
        timeoutMsg: timeoutMessages.navigation(process.env.CI === 'true')
    }
);
```

## Error Handling

### ✅ Graceful Error Handling
```typescript
try {
    await element.waitForDisplayed({ timeout: 5000 });
} catch (error) {
    console.log(`Element not displayed within timeout: ${error.message}`);
    // Handle gracefully
}
```

### ✅ Conditional Waits
```typescript
// Only wait if element might not be immediately available
if (await element.isExisting()) {
    await element.waitForDisplayed({ timeout: 5000 });
}
```

## Performance Optimization

### ✅ Minimize Wait Times
- Use the shortest timeout that reliably works
- Prefer element-specific timeouts over global timeouts
- Use `waitForDisplayed` over `waitUntil` when possible

### ✅ Batch Operations
```typescript
// ✅ Good: Batch element interactions
await Promise.all([
    pages.auth.usernameField.setValue('user@example.com'),
    pages.auth.passwordField.setValue('password123')
]);

// ❌ Bad: Sequential waits
await pages.auth.usernameField.setValue('user@example.com');
await browser.waitUntil(async () => await pages.auth.usernameField.getValue() === 'user@example.com');
await pages.auth.passwordField.setValue('password123');
```

## Debugging and Logging

### ✅ Conditional Debug Logging
```typescript
const bddLog = (message: string, type: 'setup' | 'action' | 'success' | 'warning' | 'error' = 'setup') => {
    if (process.env.DEBUG_TESTS === 'true') {
        const icons = { setup: '🔧', action: '⚙️', success: '✅', warning: '⚠️', error: '❌' };
        console.log(`${icons[type]} BDD: ${message}`);
    }
};
```

### ✅ Clear Wait Intentions
```typescript
// ✅ Good: Clear why we're waiting
await pages.auth.successMessage.waitForDisplayed({ 
    timeout: timeouts.uiInteraction,
    timeoutMsg: 'Success message did not appear after form submission'
});

// ❌ Bad: Unclear wait purpose
await browser.waitUntil(async () => await pages.auth.successMessage.isDisplayed());
```

## Migration Guidelines

### From waitUntil to Auto-Wait
1. **Identify the wait purpose**: Visibility, interactability, or state change?
2. **For visibility without interaction**: Use `waitForDisplayed()`
3. **For interactability**: Let WebdriverIO handle it automatically
4. **For complex state changes**: Keep `waitUntil` but simplify conditions

### Migration Checklist
- [ ] Remove unnecessary `waitForClickable()` calls
- [ ] Remove unnecessary `waitForEnabled()` calls  
- [ ] Replace simple visibility waits with `waitForDisplayed()`
- [ ] Simplify complex `waitUntil` conditions
- [ ] Use appropriate timeouts from centralized config
- [ ] Add clear timeout messages for debugging

## Common Mistakes to Avoid

1. **Double-waiting**: Don't wait for visibility then click - WebdriverIO handles both
2. **Over-complex conditions**: Keep `waitUntil` conditions simple and focused
3. **Inconsistent timeouts**: Use centralized timeout configuration
4. **Missing error context**: Always provide meaningful timeout messages
5. **Ignoring auto-wait**: Don't add explicit waits where WebdriverIO already handles them

## Testing Strategy

### ✅ Test Patterns
- Test with realistic timeouts (not too short, not too long)
- Test both success and failure scenarios
- Use conditional logging for debugging
- Verify element state after interactions

### ✅ Maintenance
- Regularly review wait patterns for optimization opportunities
- Monitor test execution times for performance regressions
- Update timeout configurations based on real-world performance
- Document complex wait patterns with clear comments